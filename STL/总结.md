# STL标准库

    参考资料文档：./doc/slide.pdf

![stl-header](./img/STL-HEADERS.png)

    以下三个是常用cpp网站资源:
![stl-header](./img/STL-HEADERS-1.png)

![stl-header](./img/STL-HEADERS-2.png)

![stl-header](./img/STL-HEADERS-3.png)

# STL 六大部件

![六大部件](./img/STL六大部件.png)
![六大部件](./img/STL六大部件-2.png)

![complexity](./img/complexity.png)

![区间](./img/区间.png)

![range-for](./img/range-based.png)
![auto](./img/auto.png)


## 容器

    容器结构与分类：
        1.序列容器
        2.关联容器
![结构分类1](./img/结构分类1.png)

### 顺序容器
    1、使用容器 array

![结构分类1](./img/结构分类1-1.png)
![结构分类1](./img/结构分类1-2.png)
       
    2、使用容器 vector
        note:vector的内存的扩展按照分配元素的2倍扩展

![vector-1](./img/vector-1.png)
![vector-1](./img/vector-2.png)
    
    3、使用容器 list forward_list
![list-1](./img/LIST-1.png)

![list-1](./img/forward_list.png)

    4、使用容器 deque
![deque](./img/deque.png)
![deque](./img/deque-2.png)

    5、使用容器 stack queue

![stack](./img/stack.png)
![queue](./img/queue.png)

### 关联容器
    
    1、使用容器 multiset
![multiset](./img/multiset.png)

    2、使用容器 multimap
![multimap](./img/multimap.png)

    3、unordered_multiset
![unordered_multiset](./img/unordered_multiset.png)
![unordered_multiset](./img/unordered_multiset-2.png)

    4、 unordered_multimap
![unordered_multimap](./img/unordered_multimap.png)

    5、 set
![set](./img/set.png)
    
    6、map
![map](./img/map.png)
    
    7. unordered_set
![unordered_set](./img/unordered_set.png)

    8、unordered_map
![unordered_map](./img/unordered_map.png)


## 分配器

![allocator](./img/allocator.png)

![allocator](./img/allocator-2.png)

![allocator](./img/allocator-3.png)


## 算法

## 迭代器

## 适配器

## 仿函数

## OOP(面向对象编程) VS GP（Generic Programing）

    1、OOP ：数据 + 方法 放在类中
    2、GP 将数据和方法分开

![oop1](./img/OOP1.png)

![oop1](./img/OOP-2.png)

![oop1](./img/OOP-3.png)

## 源码分析

### 操作符重载

![operator](./img/operator-1.png)

![operator](./img/operator-2.png)

![operator](./img/operator-3.png)

### 模板

### list

````c++

// GCC 2.9 版本

template <class T>
struct __list_node {
    typedef void* void_pointre;
    void_pointer prev;
    void_pointer next;
    T data;
};

template <class T, class Ref, class Ptr>
struct __list_iterator
{
    typedef __list_iterator<T, Ref, Ptr> self;
    typedef bidirectional_iterator_tag iterator_category;
    typedef T value_type;
    typedef Ptr pointer;
    typedef Ref reference;
    typedef __list_node<T>* link_type;
    typedef ptrdiff_t difference_type;
    
    link_type node;
    
    reference operator*() const { return (*node).data; }
    pointer operator->() const { return &(operator*()); }
    self& operator++() { node = (link_type)((*node).next); return *this; }
    self operator++(int) { self tmp = *this; ++*this; return tmp; }
    
};

template <class T, class Alloc = alloc>
class list {
protected:
    typedef __list_node<T> list_node;
public:
    typedef list_node* link_type;
    typedef __list_iterator<T, T&, T*> iterator;
protected:
    link_type node;
...
    
};


// Gcc 4.9 版本改进
template <class _Tp, class _Alloc = allocator<_Tp>>
class list : protected _List_base<_Tp, _Alloc>
{
public:
    typedef _List_iterator<_Tp> iterator;
};

template <class _Tp>
struct _List_iterator
{
    typedef _Tp* pointer;
    typedef _Tp& reference;
    ...
};

struct _List_node_base
{
    _List_node_base* _M_next;
    _List_node_base* _M_prev;
};

template<class _Tp>
struct _List_node : public _List_node_base {
    
    _Tp _M_data;
};

// Iterator需要遵循的原则

/*
 * 在容器和算法之间的桥梁迭代器，通常需要满足算法使用的需求，也就是算法要知道容器的数据类型，
 * iterator泛化指针的移动等信息，以下举例rotate函数的算法
 * */

template <class _Iter>
inline typename iterator_traits<_Iter>::iteraotr_category
__iterator_category(const _Iter&)
{
    return typename iterator_traits<_Iter>::iterator_category();
}

template <class _ForwardIterator>
inline void
rotate(_ForwardIterator __first, _ ForwardIterator __middle,
       _ForwardIterator __last)
{
    ...
    std::__ratate(__first, __middle, __last, std::iterator_category(__first));
}

template<calss _RandomAccessIterator>
void __rorate(_RandomAccessIterator __first,
              _RandomAccessIterator __middle,
              _RandomAccessIterator __last,
              random_access_iterator_tag)
{
    ...
    typedef typename iterator_traits<_RandomAccessIteraot>::difference_type _Disrance;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    _Distance __n = __last - __first;
    _Disrance __k = __middle - __fisrt;
    ...
    for (;;) {
        if (__k < __n - __k) {
            if (__is_pod(_ValueType) && __k == 1) {
                _ValueType __t = _GLIBCXX_MOVE(*__p);
            }
        }
    }
    ...
}

````